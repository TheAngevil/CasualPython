def des(var, var_id):
    """
    我懶惰寫來產String用的，不要太計較 XD
    """
    return f"id of {var} = {var_id}"


# Week 3
# 理解值與址。

# 1. 學會id()的作用以及出現的數字代表的意義，並利用此點學習址跟值的差異。
# 1.1 試試看print(id(999)）與 print(id(10))
print(f'{"~" * 50}1.1{"~" * 50}')
print(des("999", id(999)))
print(des("10", id(10)))

# 1.2 將10, 99 與999，分別賦予給三個變數a,b與z，印出 id(a), id(b) 與 id(z) 並與 id(10), id(99) 與 id(999)作比較。為何是這樣的結果?
print(f'{"~" * 50}1.2{"~" * 50}')
a = 10
b = 99
z = 999
print(des("10", id(10)))
print(des("a", id(a)))
print(des("99", id(99)))
print(des("b", id(b)))
print(des("999", id(999)))
print(des("z", id(z)))
print("id(a)、id(b)、id(z)分別對照id(10)、id(99)、id(999)會印出相同的數值，因為他們最終所指向的記憶體位置是相同的")

# 1.3 直接印出id(c)，會發生什麼事情? 為什麼?
print(f'{"~" * 50}1.3{"~" * 50}')
print("直接印出id(c)會跳出Error > NameError: name 'c' is not defined\n"
      "因為在Python中，物件(object)的值存在於電腦記憶體中，而變數(Variables)可以保存對物件的引用，\n"
      "在此題中變數 c 並沒有被賦予任何物件，因此無法指向該物件的記憶體位址，自然會無法讀取，出現error")
      # ex. num = 2 的含意是建立一個值為2的整數(int)物件，再將 num 指向該物件的記憶體位址，藉此存取 (然後物件的位址可以透過id()取得)

# print(id(b))
# 1.4 讓 c = b，再度印出id(c)並跟上面的id(99)與id(b)比較，有差異嗎?
print(f'{"~" * 50}1.4{"~" * 50}')
c = b
print(des("b", id(b)))
print(des("c", id(c)))
print("再度印出id(c)並跟上面的id(99)與id(b)比較並無差異，\n"
      "因為變數 c 是引用了變數 b，而變數 b 則是引用了 99 這個值，兩者最終存取的都是 99 這個值的記憶體位址")

# 1.5 嘗試印出(a==b) 以及(a is b) 結果是?
print(f'{"~" * 50}1.5{"~" * 50}')
print(a == b) #判斷物件的值是否相同
print(a is b) #is 可以用來判斷兩個物件記憶體位址是否相同
print("印出(a==b)以及(a is b)結果都是False，\n"
      "因為==是判斷兩個變數之間的值是否相等，a 的值是 10 而 b 的值是 99，故印出的結果是False\n"
      "is 則是判斷兩個變數之間引用的物件是否相同，a 引用的物件是 10 而 b 引用的物件是 99，10 與 99 的記憶體位址並不相同，故印出的結果是False")

# 1.6 讓 d = 99 +1 嘗試印出(d == 99+1 ) 以及(y is b+1) 結果是?
print(f'{"~" * 50}1.6{"~" * 50}')
d = 99 + 1
print(d == 99 + 1) #判斷物件的值是否相同
print(d is b + 1) #is 可以用來判斷兩個物件記憶體位址是否相同
print("讓 d = 99 +1 後嘗試印出(d == 99+1 )結果會是True，因為==是判斷兩個變數之間的值是否相等，d 的值是 99+1 也就是 100；而 99+1 得出來的值也是100，故印出的結果是True\n"
      "而印出(y is b+1)會跳出 NameError: name 'y' is not defined，因為變數 y 並沒有被賦予任何物件，因此無法指向該物件的記憶體位址，自然會無法判斷其與 b+1 的記憶體位址是否相同，出現error")

# 1.7 讓 y = 999+1 嘗試印出(y == 999+1 ) 以及(y is z+1) 結果是?
print(f'{"~" * 50}1.7{"~" * 50}')
y = 999 + 1
print(y == 999 + 1)
print(y is z + 1)
print("讓 y = 999+1 後嘗試印出(y == 999+1 )結果會是True，因為 y 引用的是 999+1 這個值，其與判斷式另一邊 999+1 這個值是相等的\n"
      "而印出(y is z+1)結果是False，因為雖然單看 y 是引用 999+1 也就是 1000 這個值的位址，與 z 引用的 999 再加 1 的值是相等的，"
      "但z所引用的 999 這個值超出了 -5~256 的範圍，故不會進行緩存而是重新分配他的記憶體位址，最終結果就會是不相等")

# 1.8: 1.6 的結果與 1.7有何不同，為什麼? 提示，找看看"Python 整數緩存機制"。
print(f'{"~" * 50}1.8{"~" * 50}')
print("雖然 1.6 和 1.7 皆是比較在我們看來都是相同的值，但結果會是不同的，因為Python(CPython)啟動時，為了效率更好，會把 -5~256 的整數加入到一個 global list 中（類似快取），\n"
      "所以每次我們參考這範圍的整數，就會參考到這些預先產生的物件(這些整數稱為singletons)，可以參考下面印出的結果")
print(des("999", id(999)))
print(des("z", id(z))) #z 的值是 999
print(des("1000", id(1000)))
print(des("z+1", id(z+1)))
print(des("999+1", id(999+1)))
print("1.7 這題可以看到 z 原本是引用 999 這個值的位址，所以與 999 這個值的記憶體位址會相同，但 z+1 本身因為超過 -5~256 的範圍，並不會等同取 999+1 這個值的位址，\n"
      "而是會重新分配其記憶體位址，故結果就與 1000 這個值的位址並不相等。\n"
      "1.6 這題之所以會True是因為 b+1 存在於 -5~256 的範圍，記憶體位址已預先產生並緩存了，故不會重新分配")

# 1.9: 根據 1.6 說明 == 與 is ， != 與 is not 分別的差異在? 提示，印出1.6與1.7 中分別的id
print(f'{"~" * 50}1.9{"~" * 50}')
print("== 與 != 分別用來判斷物件的'值'是否相同 與 是否不相同，\n"
      "is 與 is not 分別用來判斷物件的'記憶體位址'是否相同 與 是否不相同\n")

# 理解mutable and immutable
# 1.10 解釋為何 id(str_1)的前後id不一樣 但 id(list_1)的前後id沒有變化。請用記憶體的角度來進行說明。
print(f'{"~" * 50}1.10{"~" * 50}')
str_1 = str()
print(id(str_1))
str_1 = str_1.join("2")
print(id(str_1))

list_1 = list()
print("hello", id(list_1))
list_1.append("2")
print("hello", id(list_1))

print("id(str_1)的前後id不一樣 但 id(list_1)的前後id沒有變化，\n"
      "因為str_1是str type，而str是不可變的(immutable)，當值改變時，記憶體會給予他一個新的儲存位址；\n"
      "list_1是list type，而list是可變的(mutable)，所以改變的只是值而非記憶體空間(identity)")

# 1.11 請列出基本型別中，哪一些是mutable 以及 哪一些是 immutable
print(f'{"~" * 50}1.11{"~" * 50}')
print("mutable:list、set、dict\n" #當物件被創造出來後，其「值」(Value)可以被改變
      "immutable:bool、int、float、tuple、str、frozenset") #當物件被創造出來後，其「值」(Value)無法被改變 ex.修改變數時並不會去修改原有的值，而是重新創造出一個新的物件

# 1.12 請說明id()的用法以及出來的數字的意義，並自行查閱並根據上敘練習，說明值(value)，址(address)，引用(Reference)的概念。如有針對上敘問題的額外心得，請直接加入前面題目的說明中
print(f'{"~" * 50}1.12{"~" * 50}')
print("id()的用法以及出來的數字的意義:\n"
      "在Python中，物件的值存在於電腦記憶體中的具體位址中，而物件的記憶體空間就是identity，它是區分兩者物件之間的唯一識別碼，並且是唯讀屬性，一旦建立物件就無法更改物件的identity，\n"
      "物件的identity可透過id()來存取，id()回傳的數值是代表該物件在記憶體的位址(address)，所以可以拿來確定兩個物件是否為同一個物件，但不能用來檢查兩個物件是否為同一類型(type)的物件\n"
      "有以下兩種存取方式\n"
      "1. 直接使用內建id()函數取得 ex.id(32)\n"
      "2. 透過指向該物件的變數取得 ex. number=32; id(number)\n"
      "值(value):物件存放的資料(值)，value可變動的object稱為mutable object，value不可變動的稱為immutable object\n"
      "址(address):物件存放的地址(記憶體位址)\n"
      "引用(Reference):Python是以物件參照(Object reference)來儲存資料，故會將變數指向該物件的記憶體位址以此存取。在Python中，引用的運算符號即是「=」；\n"
      "變數指的是對具體物件的引用(reference)的名稱，而物件則是具體的記憶體位置")